from bioat.logger import set_logging_level
from bioat.lib.libcrispr import (
    TARGET_SEQ_LIB,
    run_no_PAM_sgRNA_alignment_no_chop,
    run_sgRNA_alignment
)
from bioat.lib.libcolor import (
    convert_hex_to_rgb,
    convert_rgb_to_hex,
    map_color,
    make_color_list
)

from Bio.Align import PairwiseAligner
from Bio.Seq import Seq

from matplotlib.collections import PatchCollection
from matplotlib.patches import Rectangle
from matplotlib import pyplot as plt
from tabulate import tabulate
import numpy as np
import pandas as pd
import matplotlib
import logging
import sys

matplotlib.use('Agg')
np.set_printoptions(suppress=True)


class TargetedDeepSequencing:
    def __init__(self):
        pass

    def region_heatmap(
            self,
            input_table: str,
            output_fig: str,
            target_seq: str = None,  # sgRNA
            reference_seq: str = None,  # target locus
            input_table_header: bool = True,
            output_fig_fmt: str = 'pdf',
            output_fig_dpi: int = 100,
            show_indel: bool = True,
            show_index: bool = True,
            box_border: bool = False,
            box_space: float = 0.03,
            min_color: tuple = (250, 239, 230),
            max_color: tuple = (154, 104, 57),
            min_ratio: float = 0.001,
            max_ratio: float = 0.99,
            region_extend_length: int = 25,
            local_alignment_scoring_matrix: tuple = (5, -4, -24, -8),
            local_alignment_min_score: int = 15,
            get_built_in_target_seq: bool = False,
            log_level: str = 'INFO'
    ):
        """Plot region mutation info using table generated by `bioat bam mpileup_to_table`.

        :param input_table: Path of table generated by `bioat bam mpileup_to_table`.
                This table should contain base mutation information from a short genome region (no more than 1k nt).
        :param output_fig: Path of output figure.
        :param target_seq: The program will attempt to align the sequence information specified by <target_seq> to
        the reference sequence of mpileup.table. The <target_seq> sequence can be sgRNA (if you need to specify the
        PAM sequence you can use this format, ^NGG^.). When PAM is specified, local alignment takes into account PAM
        information. If PAM is not specified, normal local alignment is performed. Formal format of <target_seq> should
        be like:

        'GAGTCCGAGCAGAAGAAGAA^GGG^', ^GGG^ refers to PAM of SpCas9-BE on `EMX1` site;\n
        '^TTTA^GCCCCAATAATCCCCACATGTCA', ^TTTA^ refers to PAM of cpf1-BE on `CDKN2A` site;\n
        'TGCTAGTAACCACGTTCTCCTGATCAAATATCACTCTCCTACTTACAGGA' refers to no PAM on `ND4` site.
        :param input_table_header: whether input_table has header or not
        :param output_fig_fmt: pdf | png
        :param output_fig_dpi: output figure dpi
        :param show_indel: whether show indel info in the out figure or not
        :param show_index: whether show index info in the out figure or not
        :param box_border: whether show box border info in the out figure or not
        :param box_space: space size between two boxes
        :param min_color: min color to plot heatmap with RGB format
        :param max_color: max color to plot heatmap with RGB format
        :param min_ratio: mutation ratio of box lower than min_ratio will show as white
        :param max_ratio: mutation ratio of box higher than min_ratio will show as ??
        :param region_extend_length: expand how many bps for the two side of this region
        :param local_alignment_scoring_matrix: set <align_match_score>  <align_mismatch_score>
                                                <align_gap_open_score> <align_gap_extension_score>
        :param local_alignment_min_score: If alignment score lower than this, consider as no appropriate alignment
        :param get_built_in_target_seq: specify to True to return built-in target_seq sequence.
        :param log_level: 'CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG', 'NOTSET'

        --- demo ---\n
        samtools mpileup test_sorted.bam --reference HK4-AOut-1.ref.upper.fa | gzip > test_sorted.mpileup.gz\n
        bioat bam mpileup_to_table test_sorted.mpileup.gz > test_sorted.mpileup.info.tsv\n
        bioat targeted_deep_sequencing region_heatmap \
            test_sorted.mpileup.info.tsv \
            > test_sorted.mpileup.info.pdf\n
        """
        set_logging_level(level=log_level)
        # set logger
        lib_name = __name__
        function_name = sys._getframe().f_code.co_name
        logger = logging.getLogger(f'{lib_name}.{function_name} ==> ')

        if get_built_in_target_seq:
            logger.info(
                f'You can use <key> in built-in <target_seq> to represent your target_seq:\n' +
                '\t<key>\t<target_seq>\n' +
                ''.join([f'\t{k}\t{v}\n' for k, v in TARGET_SEQ_LIB.items()])
            )
            logger.info('exit because of the defination for get_built_in_target_seq')
            exit(0)
        else:
            # set sgRNA info
            logger.debug(f'load target_seq = {target_seq}')

            if target_seq in TARGET_SEQ_LIB:
                logger.debug(f'target_seq information is abtained from the <key>={target_seq}')
                target_seq = TARGET_SEQ_LIB[target_seq]
                logger.debug(f'target_seq is refered to {target_seq}')
            elif target_seq is None:
                pass
            elif isinstance(target_seq, str):
                logger.debug(f'target_seq is refered to {target_seq}')
            else:
                logger.error("<target_seq> should be set as:"
                             "DNA sequence / <key> in <get_built_in_target_seq> / None,"
                             f"but your <target_seq> is {target_seq}")
                exit(1)

        # set alignment
        align_match, align_mismatch, align_gap_open, align_gap_extension = local_alignment_scoring_matrix

        aligner = PairwiseAligner()
        aligner.match = align_match
        aligner.mismatch = align_mismatch
        aligner.open_gap_score = align_gap_open
        aligner.extend_gap_score = align_gap_extension
        aligner.query_left_gap_score = 0
        aligner.query_right_gap_score = 0
        aligner.mode = "global"
        logger.debug(aligner)

        # load mpileup.info.tsv
        if input_table_header:
            df_bases = pd.read_csv(input_table, sep="\t")
        else:
            df_bases = pd.read_csv(input_table, sep="\t", header=None)

        logger.debug('df_bases.head(10):\n' + tabulate(df_bases.head(8), headers='keys', tablefmt='psql'))

        # ref_seq & ref_seq_rc
        if reference_seq:
            ref_seq = Seq(reference_seq)
            logger.debug(f'ref_seq from parameter:\n{ref_seq}')
        else:
            ref_seq = Seq("".join(df_bases.ref_base))
            logger.debug(f'ref_seq from df_bases.ref_base:\n{ref_seq}')

        ref_seq = Seq(ref_seq)
        logger.debug(f'Seq object for ref_seq:\n{ref_seq}')
        ref_seq_rc = ref_seq.reverse_complement()
        logger.debug(f'Seq object for ref_seq_rc (reverse_complement):\n{ref_seq_rc}')

        # target_seq
        if target_seq is None:
            target_seq = ref_seq
            PAM_seq = None
        elif '^' in target_seq:
            if target_seq.find('^') == 0:
                _, PAM_seq, target_seq = target_seq.strip().split('^')
                target_seq = Seq(target_seq.upper())
                PAM_seq = 'left_' + PAM_seq
            else:
                target_seq, PAM_seq, _ = target_seq.strip().split('^')
                target_seq = Seq(target_seq.upper())
                PAM_seq = 'right_' + PAM_seq
        else:
            logger.debug(f'no PAM sequence is defined from target_seq = {target_seq}')
            target_seq = Seq(target_seq)
            PAM_seq = None

        logger.debug(f'parse target_seq: target_seq={target_seq}, PAM_seq={PAM_seq}')

        # fwd alignment & rev alignment
        final_align_forward = run_no_PAM_sgRNA_alignment_no_chop(ref_seq, target_seq, aligner)
        logger.debug(f'final_align_forward:\n{final_align_forward}')
        final_align_reverse = run_no_PAM_sgRNA_alignment_no_chop(ref_seq_rc, target_seq, aligner)
        logger.debug(f'final_align_reverse:\n{final_align_reverse}')

        fwd = final_align_forward[0]
        rev = final_align_reverse[0]

        logger.info(f"""Forward best alignment:
reference  : {fwd['alignment']['aligned_reference_seq'][fwd['ref_align_start_index']: fwd['ref_align_end_index'] + 1]}
align_info : {fwd['alignment']['aligned_seq_info'][fwd['ref_align_start_index']: fwd['ref_align_end_index'] + 1]}
target_seq : {fwd['alignment']['aligned_target_seq'][fwd['ref_align_start_index']: fwd['ref_align_end_index'] + 1]}
align_score: {fwd['alignment_score']}""")

        # rev alignment
        logger.info(f"""Reverse best alignment:
reference  : {rev['alignment']['aligned_reference_seq'][rev['ref_align_start_index']: rev['ref_align_end_index'] + 1]}
align_info : {rev['alignment']['aligned_seq_info'][rev['ref_align_start_index']: rev['ref_align_end_index'] + 1]}
target_seq : {rev['alignment']['aligned_target_seq'][rev['ref_align_start_index']: rev['ref_align_end_index'] + 1]}
align_score: {rev['alignment_score']}""")

        # make alignment info
        sgRNA_align = [""] * len(ref_seq)
        sgRNA_align_insert = [""] * len(ref_seq)

        DNA_rev_cmp_dict = {
            "A": "T",
            "T": "A",
            "C": "G",
            "G": "C",
            "N": "N",
            "-": "-"}

        # define align direction and final align res
        if any([x >= local_alignment_min_score for x in (fwd['alignment_score'], rev['alignment_score'])]):
            if fwd['alignment_score'] >= rev['alignment_score']:
                final_align_direction = "Forward Alignment"
                final_align = fwd
            else:
                final_align_direction = "Reverse Alignment"
                final_align = rev
        else:
            logger.critical("Alignment Error!")
            exit(1)

        # make sgRNA alignment info
        final_align_info = final_align[7][final_align[4]: final_align[5] + 1]
        final_align_ref = final_align[6][final_align[4]: final_align[5] + 1]
        final_align_sgRNA = final_align[8][final_align[4]: final_align[5] + 1]

        final_align_ref_gap_count = final_align_ref.count("-")
        final_align_sgRNA_gap_count = final_align_sgRNA.count("-")

        ref_align_gap_count = 0
        ref_del_str = ""

        # select bmat file
        if (final_align_direction == "Forward Alignment") or (
                final_align_direction == "Reverse Alignment"):
            sgRNA_start = final_align[4]

            for align_index, align_ref in enumerate(final_align_ref):
                if align_ref != "-":
                    sgRNA_align[sgRNA_start + align_index -
                                ref_align_gap_count] = ref_del_str + final_align_sgRNA[align_index]
                    ref_del_str = ""
                else:
                    ref_align_gap_count += 1
                    ref_del_str += final_align_sgRNA[align_index]
                    sgRNA_align_insert[sgRNA_start +
                                       align_index] = final_align_sgRNA[align_index]

            # add PAM info
            if final_align_direction == "Reverse Alignment":
                sgRNA_align = sgRNA_align[::-1]
                sgRNA_align_insert = sgRNA_align_insert[::-1]

        # set possible_sgRNA_region
        sgRNA_align_start = final_align[4]
        sgRNA_align_end = final_align[5]

        possible_sgRNA_region_start = max(
            sgRNA_align_start - region_extend_length, 0)
        possible_sgRNA_region_end = min(
            sgRNA_align_end + region_extend_length,
            len(ref_seq) - 1)
        possible_sgRNA_region = [
            possible_sgRNA_region_start,
            possible_sgRNA_region_end]

        # select df_bases
        bmat_table_select = df_bases[possible_sgRNA_region[0]: possible_sgRNA_region[1]]

        # ---------------------------------------------------------------->>>>>
        # make plot
        # ---------------------------------------------------------------->>>>>

        # --------------------------------------------------->>>>>
        # set color
        # --------------------------------------------------->>>>>
        # show indel
        indel_plot_state = show_indel
        index_plot_state = show_index
        box_border_plot_state = box_border

        # set panel size
        panel_box_width = 0.4
        panel_box_heigth = 0.4
        panel_space = 0.05
        panel_box_space = box_space

        # color part
        base_color_dict = {
            "A": "#04E3E3",
            "T": "#F9B874",
            "C": "#B9E76B",
            "G": "#F53798",
            "N": "#AAAAAA",
            "-": "#AAAAAA"}

        # make color breaks
        color_break_num = 20
        break_step = 1.0 / color_break_num
        min_color_value = min_ratio
        max_color_value = max_ratio
        color_break = np.round(
            np.arange(
                min_color_value,
                max_color_value,
                break_step),
            5)

        try:
            color_list = make_color_list(
                min_color, max_color, len(color_break) - 1, "Hex")
            color_list = ["#FFFFFF"] + color_list
        except BaseException:
            print
            min_color, max_color
            print
            color_break

        # get plot info
        total_box_count = possible_sgRNA_region[1] - possible_sgRNA_region[0]

        # calculate base info and fix zero
        base_sum_count = bmat_table_select[["A", "G", "C", "T"]].apply(
            lambda x: x.sum(), axis=1)
        total_sum_count = bmat_table_select[[
            "A", "G", "C", "T", "del_count", "insert_count"]].apply(lambda x: x.sum(), axis=1)
        base_sum_count[np.where(base_sum_count == 0)[0]] = 1
        total_sum_count[np.where(total_sum_count == 0)[0]] = 1

        # make plot size
        plot_data_list = None
        panel_space_coef = None
        panel_height_coef = None

        if indel_plot_state:
            panel_height_coef = [0.5, 0.9, 0.9] + [0.5] * 6 + [0.5] * 6
            panel_space_coef = [1, 1, 1] + [0.3] * \
                               3 + [1, 0.3, 1] + [0.3] * 3 + [1, 0.3]
            plot_data_list = [
                ["Index", bmat_table_select.chr_index],
                ["On-target", sgRNA_align[possible_sgRNA_region[0]: possible_sgRNA_region[1]]],
                ["Ref", bmat_table_select.ref_base],
                ["A", np.array(bmat_table_select["A"])],
                ["G", np.array(bmat_table_select["G"])],
                ["C", np.array(bmat_table_select["C"])],
                ["T", np.array(bmat_table_select["T"])],
                ["Del", np.array(bmat_table_select["del_count"])],
                ["Ins", np.array(bmat_table_select["insert_count"])],
                ["A.ratio", list(bmat_table_select["A"] / base_sum_count)],
                ["G.ratio", list(bmat_table_select["G"] / base_sum_count)],
                ["C.ratio", list(bmat_table_select["C"] / base_sum_count)],
                ["T.ratio", list(bmat_table_select["T"] / base_sum_count)],
                ["Del.ratio", list(bmat_table_select["del_count"] / total_sum_count)],
                ["Ins.ratio", list(bmat_table_select["insert_count"] / total_sum_count)]
            ]
        else:
            panel_height_coef = [0.5, 0.9, 0.9] + [0.5] * 4 + [0.5] * 4
            panel_space_coef = [1, 1, 1] + [0.3] * 3 + [1] + [0.3] * 3
            plot_data_list = [
                ["Index", bmat_table_select.chr_index],
                ["On-target", sgRNA_align[possible_sgRNA_region[0]: possible_sgRNA_region[1]]],
                ["Ref", bmat_table_select.ref_base],
                ["A", np.array(bmat_table_select["A"])],
                ["G", np.array(bmat_table_select["G"])],
                ["C", np.array(bmat_table_select["C"])],
                ["T", np.array(bmat_table_select["T"])],
                ["A.ratio", list(bmat_table_select["A"] / base_sum_count)],
                ["G.ratio", list(bmat_table_select["G"] / base_sum_count)],
                ["C.ratio", list(bmat_table_select["C"] / base_sum_count)],
                ["T.ratio", list(bmat_table_select["T"] / base_sum_count)]
            ]

        # get box and space info
        box_height_list = np.array(panel_height_coef) * panel_box_heigth
        panel_space_list = np.array(panel_space_coef) * panel_space

        # calculate figure total width and height
        figure_width = total_box_count * panel_box_width + \
                       (total_box_count - 1) * panel_box_space + panel_box_width * 2
        figure_height = sum(box_height_list) + sum(panel_space_list)

        # make all box_x
        box_x_vec = np.arange(
            0,
            figure_width +
            panel_box_width,
            panel_box_width +
            panel_box_space)
        box_x_vec = box_x_vec[:(len(ref_seq) + 1)]

        # make box border
        if box_border_plot_state:
            box_edgecolor = "#AAAAAA"
            box_linestyle = "-"
            box_linewidth = 2
        else:
            box_edgecolor = "#FFFFFF"
            box_linestyle = "None"
            box_linewidth = 0

        # make box_y initialize
        current_y = 0

        # plot region
        # set new figure
        fig = plt.figure(figsize=(figure_width * 1.1, figure_height * 1.1))
        ax = fig.add_subplot(111, aspect="equal")
        plt.xlim([0, figure_width])
        plt.ylim([-figure_height, 0])
        plt.axis("off")

        # make plot
        text_list = []
        patches = []

        for panel_index in range(len(panel_height_coef)):

            # panel name
            panel_name = plot_data_list[panel_index][0]
            panel_name_x = box_x_vec[0]
            panel_name_y = current_y - box_height_list[panel_index] * 0.5
            text_list.append((panel_name_x, panel_name_y, panel_name, 10))

            # plot panel box
            if panel_name == "Index":
                # don't draw box, only add text
                for index, box_value in enumerate(
                        plot_data_list[panel_index][1]):
                    box_x = box_x_vec[index + 1]
                    text_list.append(
                        (box_x +
                         panel_box_width *
                         0.5,
                         current_y -
                         box_height_list[panel_index] *
                         0.5,
                         str(box_value),
                         7))

                # make next panel_y
                current_y = current_y - \
                            (box_height_list[panel_index] + panel_space_list[panel_index])

            elif panel_name in ["On-target", "Ref"]:
                for index, box_value in enumerate(
                        plot_data_list[panel_index][1]):
                    if box_value == "":
                        box_fill = False
                        box_color = "#FFFFFF"

                    else:
                        if "Reverse" in final_align_direction:
                            if panel_name == "Ref":
                                box_value = "".join(
                                    [DNA_rev_cmp_dict.get(x) for x in box_value])
                            else:
                                pass

                            box_color = base_color_dict.get(box_value[0])

                        else:
                            box_color = base_color_dict.get(box_value[-1])

                        if not box_color:
                            box_fill = False
                            box_color = "#FFFFFF"
                        else:
                            box_fill = True

                    box_x = box_x_vec[index + 1]

                    patches.append(Rectangle(
                        xy=(box_x, current_y - box_height_list[panel_index]),
                        width=panel_box_width,
                        height=box_height_list[panel_index],
                        fill=box_fill,
                        alpha=1,
                        linestyle=box_linestyle,
                        linewidth=box_linewidth,
                        edgecolor=box_edgecolor,
                        facecolor=box_color)
                    )

                    # text
                    text_list.append(
                        (box_x +
                         0.5 *
                         panel_box_width,
                         current_y -
                         0.5 *
                         box_height_list[panel_index],
                         str(box_value),
                         16))

                # make next panel_y
                current_y = current_y - \
                            (box_height_list[panel_index] + panel_space_list[panel_index])

            elif panel_name in ["A", "G", "C", "T", "Del", "Ins"]:
                if panel_name in ["Del", "Ins"]:
                    box_ratio = plot_data_list[panel_index][1] / \
                                total_sum_count
                else:
                    box_ratio = plot_data_list[panel_index][1] / base_sum_count

                box_color_list = map_color(box_ratio, color_break, color_list)
                for index, box_value in enumerate(
                        plot_data_list[panel_index][1]):
                    box_color = box_color_list[index]
                    box_x = box_x_vec[index + 1]

                    patches.append(Rectangle(
                        xy=(box_x, current_y - box_height_list[panel_index]),
                        width=panel_box_width,
                        height=box_height_list[panel_index],
                        fill=True,
                        alpha=1,
                        linestyle=box_linestyle,
                        linewidth=box_linewidth,
                        edgecolor=box_edgecolor,
                        facecolor=box_color)
                    )

                    # text
                    text_list.append(
                        (box_x +
                         0.5 *
                         panel_box_width,
                         current_y -
                         0.5 *
                         box_height_list[panel_index],
                         str(box_value),
                         6))

                # make next panel_y
                current_y = current_y - \
                            (box_height_list[panel_index] + panel_space_list[panel_index])

            else:
                box_color_list = map_color(
                    plot_data_list[panel_index][1], color_break, color_list)
                for index, box_value in enumerate(
                        plot_data_list[panel_index][1]):
                    box_color = box_color_list[index]
                    box_x = box_x_vec[index + 1]

                    patches.append(Rectangle(
                        xy=(box_x, current_y - box_height_list[panel_index]),
                        width=panel_box_width,
                        height=box_height_list[panel_index],
                        fill=True,
                        alpha=1,
                        linestyle=box_linestyle,
                        linewidth=box_linewidth,
                        edgecolor=box_edgecolor,
                        facecolor=box_color)
                    )

                    # text
                    text_list.append(
                        (box_x +
                         0.5 *
                         panel_box_width,
                         current_y -
                         0.5 *
                         box_height_list[panel_index],
                         round(
                             box_value *
                             100,
                             4),
                         6))

                # make next panel_y
                if panel_index < len(panel_space_list):
                    current_y = current_y - \
                                (box_height_list[panel_index] + panel_space_list[panel_index])

                    # plot box
        ax.add_collection(PatchCollection(patches, match_original=True))

        # add text
        for text_x, text_y, text_info, text_fontsize in text_list:
            plt.text(
                x=text_x,
                y=text_y,
                s=text_info,
                horizontalalignment='center',
                verticalalignment='center',
                fontsize=text_fontsize,
                fontname="Arial"
            )

        # output plot
        fig.savefig(
            fname=output_fig,
            bbox_inches='tight',
            dpi=output_fig_dpi,
            format=output_fig_fmt)

    # def region_heatmap_merge(self):
    #     pass


if __name__ == '__main__':
    TargetedDeepSequencing.region_heatmap()
    pass
